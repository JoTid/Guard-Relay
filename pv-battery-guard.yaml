esphome:
  name: pv-battery-guard
  friendly_name: PV Battery Guard
  # Optimization 1: Reduces binary size and improves performance
  project:
    name: "battery.guard"
    version: "1.1"

  platformio_options:
    board_build.f_cpu: 240000000L # Ensure it runs at full clock

esp32:
  board: esp32dev
  framework:
    type: esp-idf
  # Fixes the warning in the log
  variant: ESP32
  # If your chip is newer, this enables modern instructions
  # minimum_chip_revision: 3

# Enable Home Assistant API
api:
  encryption:
    key: !secret battery_guard_ha_api_key

ota:
  - platform: esphome
    password: !secret battery_guard_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # manual IP added because the ESP is on a different network
  manual_ip:
    # Set this to the IP of the ESP
    static_ip: !secret battery_guard_static_ip
    # Set this to the IP address of the router. Often ends with .1
    gateway: !secret battery_guard_gateway
    # The subnet of the network. 255.255.255.0 works for most home networks.
    subnet: !secret battery_guard_subnet

  power_save_mode: none

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Pv-Battery-Guard"
    password: !secret battery_guard_ap_password

captive_portal:

http_request:
  #useragent: esphome/device
  useragent: "esph/1"
  timeout: 5s
  # Larger buffers prevent the ESP from stalling while receiving
  buffer_size_rx: 2048

# Enable logging
logger:
  level: INFO

sensor:
  - platform: template
    name: "Battery Voltage"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 2

  - platform: template
    name: "OpenDTU Error Counter"
    id: dtu_error_counter
    accuracy_decimals: 0

  - platform: template
    name: "Batterie SOC"
    id: battery_soc
    unit_of_measurement: "%"
    accuracy_decimals: 1
    icon: "mdi:battery"

switch:
  - platform: gpio
    pin: GPIO2
    id: ac_relay
    name: "Protection Relay"
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "Automatic Mode"
    id: auto_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:robot"

#PV Battery Guard - Logic: (Voltage OR SOC < Min) -> OFF | (Voltage AND SOC > Max) -> ON
number:
  # Voltage Thresholds
  - platform: template
    name: "Cutoff Voltage (V_min)"
    id: v_min_cutoff
    min_value: 40.0
    max_value: 48.0
    step: 0.1
    initial_value: 45.0
    unit_of_measurement: "V"
    mode: box
    restore_value: true
    optimistic: true

  - platform: template
    name: "Recovery Voltage (V_max)"
    id: v_max_recovery
    min_value: 48.1
    max_value: 56.0
    step: 0.1
    initial_value: 52.0
    unit_of_measurement: "V"
    mode: box
    restore_value: true
    optimistic: true

  # SOC Thresholds
  - platform: template
    name: "Cutoff SOC (%_min)"
    id: soc_min_cutoff
    min_value: 5
    max_value: 30
    step: 1
    initial_value: 15
    unit_of_measurement: "%"
    mode: box
    restore_value: true
    optimistic: true

  - platform: template
    name: "Recovery SOC (%_max)"
    id: soc_max_recovery
    min_value: 31
    max_value: 100
    step: 1
    initial_value: 40
    unit_of_measurement: "%"
    mode: box
    restore_value: true
    optimistic: true

interval:
  - interval: 10s
    startup_delay: 2s # Waits after boot until WiFi/API are stable
    then:
      - http_request.get:
          # URL of the OpenDTU endpoint that provides the battery data
          url: http://192.168.2.54/api/livedata/status
          capture_response: true  # ESSENTIAL so that we can process the response in Lambda
          on_response:
            then:
              - if:
                  condition:
                    lambda: return response->status_code == 200;
                  then:
                    - lambda: |-
                        json::parse_json(body, [](JsonObject root) -> bool {
                            bool success = false;
                            
                            // 1. Extract voltage
                            // Path in JSON: root["battery"]["voltage"]["v"]
                            if (root["battery"]["voltage"]["v"]) {
                                float v = root["battery"]["voltage"]["v"];
                                id(battery_voltage).publish_state(v);
                                success = true;
                            }
                            
                            // 2. Extract SOC
                            if (root["battery"]["soc"]["v"]) {
                                float soc = root["battery"]["soc"]["v"];
                                id(battery_soc).publish_state(soc);
                                success = true;
                            }

                            if (success) {
                                id(dtu_error_counter).publish_state(0);
                                return true;
                            } else {
                                ESP_LOGW("http_test", "JSON path battery.voltage.v not found!");
                                return false;
                            }
                        });
                  else:
                    - logger.log:
                        format: "Error: Status: %d"
                        args: [ 'response->status_code' ]
                    - lambda: "id(dtu_error_counter).publish_state(id(dtu_error_counter).state + 1);"

              # check safety conditions after processing the response
              - script.execute: check_safety_conditions


script:
  - id: check_safety_conditions
    then:
      - lambda: |-
          // 1. Exit if manual mode is active
          if (!id(auto_mode).state) {
            ESP_LOGD("safety", "Auto mode disabled - skipping logic.");
            return; 
          }

          // 2. Get current sensor values
          float v = id(battery_voltage).state;
          float soc = id(battery_soc).state;
          float err = id(dtu_error_counter).state;
          
          // 3. Get thresholds from HA numbers
          float v_off = id(v_min_cutoff).state;
          float v_on  = id(v_max_recovery).state;
          float soc_off = id(soc_min_cutoff).state;
          float soc_on  = id(soc_max_recovery).state;

          // 4. Logic Decision
          // CRITICAL: Turn OFF if error or any value below limit
          bool critical = (err >= 3) || 
                          (!std::isnan(v) && v < v_off) || 
                          (!std::isnan(soc) && soc < soc_off);

          // RECOVERY: Turn ON only if NO error and ALL values above recovery limit
          bool recovery = (err == 0) && 
                          (!std::isnan(v) && v >= v_on) && 
                          (!std::isnan(soc) && soc >= soc_on);

          // 5. Execution
          if (critical && id(ac_relay).state) {
              id(ac_relay).turn_off();
              ESP_LOGW("safety", "PROTECTION: OFF -> V:%.1f (Min:%.1f), SOC:%.1f (Min:%.1f)", v, v_off, soc, soc_off);
          } 
          else if (recovery && !id(ac_relay).state) {
              id(ac_relay).turn_on();
              ESP_LOGI("safety", "RECOVERY: ON -> V:%.1f (Req:%.1f), SOC:%.1f (Req:%.1f)", v, v_on, soc, soc_on);
          }